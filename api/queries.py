# AUTOGENERATED FROM:
#     'queries/acceptFriendRequest.edgeql'
#     'queries/deleteFriend.edgeql'
#     'queries/deleteFriendRequest.edgeql'
#     'queries/deleteGlobalUserBoard.edgeql'
#     'queries/inserUserFromLocalProvider.edgeql'
#     'queries/insertBoard.edgeql'
#     'queries/insertFriendRequest.edgeql'
#     'queries/insertUserFromGitHubProvider.edgeql'
#     'queries/rejectFriendRequest.edgeql'
#     'queries/searchUserByUsername.edgeql'
#     'queries/selectFriendRequests.edgeql'
#     'queries/selectFriendRequestsSent.edgeql'
#     'queries/selectFriends.edgeql'
#     'queries/selectGlobalIdentity.edgeql'
#     'queries/selectGlobalUser.edgeql'
#     'queries/selectGlobalUserBoard.edgeql'
#     'queries/selectManyGlobalUserBoards.edgeql'
#     'queries/selectUserAvatar.edgeql'
#     'queries/updateGlobalUser.edgeql'
#     'queries/updateGlobalUserBoard.edgeql'
#     'queries/usernameExists.edgeql'
# WITH:
#     $ gel-py --target blocking --file api/queries.py


from __future__ import annotations
import dataclasses
import datetime
import enum
import gel
import uuid


class NoPydanticValidation:
    @classmethod
    def __get_pydantic_core_schema__(cls, _source_type, _handler):
        # Pydantic 2.x
        from pydantic_core.core_schema import any_schema
        return any_schema()

    @classmethod
    def __get_validators__(cls):
        # Pydantic 1.x
        from pydantic.dataclasses import dataclass as pydantic_dataclass
        _ = pydantic_dataclass(cls)
        cls.__pydantic_model__.__get_validators__ = lambda: []
        return []


class BoardType(enum.Enum):
    STELLAR = "Stellar"
    GALACTIC = "Galactic"
    COSMIC = "Cosmic"


class BoardType02(enum.Enum):
    STELLAR = "Stellar"
    GALACTIC = "Galactic"
    COSMIC = "Cosmic"


@dataclasses.dataclass
class acceptFriendRequestResult(NoPydanticValidation):
    id: uuid.UUID


@dataclasses.dataclass
class deleteFriendResult(NoPydanticValidation):
    id: uuid.UUID


@dataclasses.dataclass
class deleteGlobalUserBoardResult(NoPydanticValidation):
    id: uuid.UUID


@dataclasses.dataclass
class inserUserFromLocalProviderResult(NoPydanticValidation):
    id: uuid.UUID


@dataclasses.dataclass
class searchUserByUsernameResult(NoPydanticValidation):
    id: uuid.UUID
    username: str | None
    avatar: bytes | None


@dataclasses.dataclass
class selectFriendRequestsResult(NoPydanticValidation):
    id: uuid.UUID
    sender: searchUserByUsernameResult
    created_at: datetime.datetime


@dataclasses.dataclass
class selectFriendRequestsSentResult(NoPydanticValidation):
    id: uuid.UUID
    recipient: searchUserByUsernameResult
    created_at: datetime.datetime


@dataclasses.dataclass
class selectFriendsResult(NoPydanticValidation):
    id: uuid.UUID
    friend: searchUserByUsernameResult | None
    created_at: datetime.datetime


@dataclasses.dataclass
class selectGlobalIdentityResult(NoPydanticValidation):
    subject: str
    issuer: str
    id: uuid.UUID
    created_at: datetime.datetime
    modified_at: datetime.datetime


@dataclasses.dataclass
class selectGlobalUserBoardResult(NoPydanticValidation):
    id: uuid.UUID
    boardType: BoardType02
    name: str | None
    secret_key_hash: str | None
    secret_updated_at: datetime.datetime | None
    last_connected_at: datetime.datetime | None


@dataclasses.dataclass
class selectGlobalUserResult(NoPydanticValidation):
    username: str | None
    id: uuid.UUID
    email: str | None
    avatar: bytes | None


@dataclasses.dataclass
class updateGlobalUserBoardResult(NoPydanticValidation):
    last_connected_at: datetime.datetime | None
    secret_updated_at: datetime.datetime | None
    secret_key_hash: str | None
    name: str | None
    boardType: BoardType02
    id: uuid.UUID


def acceptFriendRequest(
    executor: gel.Executor,
    *,
    request_id: uuid.UUID,
) -> acceptFriendRequestResult | None:
    return executor.query_single(
        """\
        with
            request := assert_single(
                select FriendRequest
                filter .id = <uuid>$request_id
                    and .recipient.id = global current_user.id
            ),
            sender := request.sender,
            recipient := request.recipient
        insert Friend {
            user1 := sender,
            user2 := recipient
        }
        unless conflict on ((.user1, .user2))
        else (
            select Friend
            filter (.user1 = sender and .user2 = recipient)
                or (.user1 = recipient and .user2 = sender)
        );

        delete FriendRequest
        filter .id = <uuid>$request_id;\
        """,
        request_id=request_id,
    )


def deleteFriend(
    executor: gel.Executor,
    *,
    friend_id: uuid.UUID,
) -> list[deleteFriendResult]:
    return executor.query(
        """\
        delete Friend
        filter (
            (.user1.id = global current_user.id and .user2.id = <uuid>$friend_id)
            or (.user2.id = global current_user.id and .user1.id = <uuid>$friend_id)
        );\
        """,
        friend_id=friend_id,
    )


def deleteFriendRequest(
    executor: gel.Executor,
    *,
    request_id: uuid.UUID,
) -> acceptFriendRequestResult | None:
    return executor.query_single(
        """\
        delete FriendRequest
        filter .id = <uuid>$request_id
            and .sender.id = global current_user.id;\
        """,
        request_id=request_id,
    )


def deleteGlobalUserBoard(
    executor: gel.Executor,
    *,
    board_id: uuid.UUID,
) -> deleteGlobalUserBoardResult | None:
    return executor.query_single(
        """\
        delete assert_single(
          select Board {*}
          filter .id = <uuid>$board_id and assert_single(
            .owner.identity = global ext::auth::ClientTokenIdentity
          )
        );\
        """,
        board_id=board_id,
    )


def inserUserFromLocalProvider(
    executor: gel.Executor,
) -> inserUserFromLocalProviderResult:
    return executor.query_single(
        """\
        with
          identity := (select global ext::auth::ClientTokenIdentity),
          emailFactor := (
            select ext::auth::EmailFactor {email} 
            filter .identity.id = identity.id
          ),
        insert User {
          identity := identity,
          email := emailFactor.email
        }\
        """,
    )


def insertBoard(
    executor: gel.Executor,
    *,
    board_type: BoardType,
) -> deleteGlobalUserBoardResult:
    return executor.query_single(
        """\
        insert Board {
          boardType := select <BoardType>$board_type,
          owner := select assert_single(
            select User {*}
            filter assert_single(.identity = global ext::auth::ClientTokenIdentity)
          )
        }\
        """,
        board_type=board_type,
    )


def insertFriendRequest(
    executor: gel.Executor,
    *,
    recipient_id: uuid.UUID,
) -> acceptFriendRequestResult | None:
    return executor.query_single(
        """\
        insert FriendRequest {
            sender := global current_user,
            recipient := assert_single(
                select User
                filter .id = <uuid>$recipient_id
            )
        }
        unless conflict on ((.sender, .recipient))
        else (
            select FriendRequest
            filter .sender = global current_user
                and .recipient.id = <uuid>$recipient_id
        );\
        """,
        recipient_id=recipient_id,
    )


def insertUserFromGitHubProvider(
    executor: gel.Executor,
    *,
    email: str,
) -> inserUserFromLocalProviderResult:
    return executor.query_single(
        """\
        with
          identity := (select global ext::auth::ClientTokenIdentity),
        insert User {
          identity := identity,
          email := <str>$email
        }\
        """,
        email=email,
    )


def rejectFriendRequest(
    executor: gel.Executor,
    *,
    request_id: uuid.UUID,
) -> acceptFriendRequestResult | None:
    return executor.query_single(
        """\
        delete FriendRequest
        filter .id = <uuid>$request_id
            and .recipient.id = global current_user.id;\
        """,
        request_id=request_id,
    )


def searchUserByUsername(
    executor: gel.Executor,
    *,
    username: str,
) -> list[searchUserByUsernameResult]:
    return executor.query(
        """\
        with
            current_user_id := global current_user.id
        select User {
            id,
            username,
            avatar
        }
        filter .username ilike '%' ++ <str>$username ++ '%'
            and .id != current_user_id
            and not exists (
                select Friend
                filter (
                    (.user1.id = current_user_id and .user2.id = .id)
                    or (.user2.id = current_user_id and .user1.id = .id)
                )
            )
            and not exists (
                select FriendRequest
                filter (
                    (.sender.id = current_user_id and .recipient.id = .id)
                    or (.recipient.id = current_user_id and .sender.id = .id)
                )
            )
        order by .username
        limit 10;\
        """,
        username=username,
    )


def selectFriendRequests(
    executor: gel.Executor,
) -> list[selectFriendRequestsResult]:
    return executor.query(
        """\
        select FriendRequest {
            id,
            sender: {
                id,
                username,
                avatar
            },
            created_at
        }
        filter .recipient.id = global current_user.id
        order by .created_at desc;\
        """,
    )


def selectFriendRequestsSent(
    executor: gel.Executor,
) -> list[selectFriendRequestsSentResult]:
    return executor.query(
        """\
        select FriendRequest {
            id,
            recipient: {
                id,
                username,
                avatar
            },
            created_at
        }
        filter .sender.id = global current_user.id
        order by .created_at desc;\
        """,
    )


def selectFriends(
    executor: gel.Executor,
) -> list[selectFriendsResult]:
    return executor.query(
        """\
        with
            current_user_id := global current_user.id,
            friendships := (
                select Friend
                filter .user1.id = current_user_id
                    or .user2.id = current_user_id
            )
        select friendships {
            id,
            friend := (
                select User
                filter .id = (
                    friendships.user1.id if friendships.user2.id = current_user_id
                    else friendships.user2.id
                )
            ) {
                id,
                username,
                avatar
            },
            created_at
        }
        order by .created_at desc;\
        """,
    )


def selectGlobalIdentity(
    executor: gel.Executor,
) -> selectGlobalIdentityResult:
    return executor.query_single(
        """\
        select assert_exists(
          assert_single(
            select global ext::auth::ClientTokenIdentity { * }
          )
        )\
        """,
    )


def selectGlobalUser(
    executor: gel.Executor,
) -> selectGlobalUserResult | None:
    return executor.query_single(
        """\
        select assert_single(
            select User {*}
            filter assert_single(.identity = global ext::auth::ClientTokenIdentity)
        );\
        """,
    )


def selectGlobalUserBoard(
    executor: gel.Executor,
    *,
    board_id: uuid.UUID,
) -> selectGlobalUserBoardResult | None:
    return executor.query_single(
        """\
        select assert_single(
          select Board {*}
          filter .id = <uuid>$board_id and assert_single(
            .owner.identity = global ext::auth::ClientTokenIdentity
          )
        );\
        """,
        board_id=board_id,
    )


def selectManyGlobalUserBoards(
    executor: gel.Executor,
) -> list[selectGlobalUserBoardResult]:
    return executor.query(
        """\
        select Board {*}
        filter assert_single(
            .owner.identity = global ext::auth::ClientTokenIdentity
        );\
        """,
    )


def selectUserAvatar(
    executor: gel.Executor,
    *,
    user_id: uuid.UUID,
) -> bytes | None:
    return executor.query_single(
        """\
        select assert_single(
            select User
            filter .id = <uuid>$user_id
        ).avatar;\
        """,
        user_id=user_id,
    )


def updateGlobalUser(
    executor: gel.Executor,
    *,
    avatar: bytes | None = None,
    username: str | None = None,
    email: str | None = None,
) -> selectGlobalUserResult | None:
    return executor.query_single(
        """\
        with
          user := assert_single(
            select User
            filter assert_single(
              .identity = global ext::auth::ClientTokenIdentity
            )
          ),
          updated_user := (
            update user
            set {
              avatar := <optional bytes>$avatar ?? .avatar,
              username := <optional str>$username ?? .username,
              email := <optional str>$email ?? .email
            }
          )
        select updated_user {*};\
        """,
        avatar=avatar,
        username=username,
        email=email,
    )


def updateGlobalUserBoard(
    executor: gel.Executor,
    *,
    board_id: uuid.UUID,
    board_type: BoardType | None = None,
    name: str | None = None,
    secret_key_hash: str | None = None,
) -> updateGlobalUserBoardResult | None:
    return executor.query_single(
        """\
        with
          board := select assert_single(
            select Board {*}
            filter .id = <uuid>$board_id and assert_single(
              .owner.identity = global ext::auth::ClientTokenIdentity
            )
          ),
          updated_board := (
            update board
            set {
              boardType := <optional BoardType>$board_type ?? .boardType,
              name := <optional str>$name ?? .name,
              secret_key_hash := <optional str>$secret_key_hash ?? .secret_key_hash
            }
          )
        select updated_board{*};\
        """,
        board_id=board_id,
        board_type=board_type,
        name=name,
        secret_key_hash=secret_key_hash,
    )


def usernameExists(
    executor: gel.Executor,
    *,
    username: str,
) -> bool:
    return executor.query_single(
        """\
        select exists (
          select User
          filter .username = <str>$username
        );\
        """,
        username=username,
    )
